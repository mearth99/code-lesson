//1520번 내리막길
 /* 입력
첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 
이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.
 */

 /* 출력
첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.
 */

/* 예상
DP를 무엇으로 정의할지 똑같은 고민을 하고 있다. "현재 위치에서 목적지까지 갈 수 있는 경로의 수"로 생각해보자. 그렇다면 목적지까지 세는 방법은 어떻게 될까?
방향은 상하좌우 전부 갈 수 있다. 그러면, 방향마다 전부 재귀함수를 돌려서 탐색하는 것이고 하나의 방향을 우선적으로 탐색하기 때문에 이 방법은 DFS가 된다.
*/
/* 결과
내가 이해할만큼 깔끔한 코드였다. 한번 생각하니, 이정도는 짤수있을 것 같은데, 자꾸만 확인하게 된다. 그래도 아이디어부터 결과까지 한번 보니까 바로 설계가 되긴한다.
다만 이런 아이디어를 떠올리기가 왜 어렵냐..
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int M,N; //세로 M, 가로 N
int map[501][501];
int dp[501][501];
int go_x[4] = {0, 0, -1, 1};
int go_y[4] = {-1, 1, 0, 0};
int DFS(int row, int col){
  if(row==0 && col==0) return 1; //성공적으로 탐색이 마무리 되었을 경우
  if(dp[row][col]!= -1) return dp[row][col]; //이미 이번 DFS에 탐색한 경우 바로 종료한다.
  if((row<0 || row >= M) &&(col<0 || col >=N)) return 0; //허용된 범위를 벗어난 경우 종료한다.
  //다음에 탐색할 방향은 Go_x를 통해 움직일 수 있다. 그런데, 탐색하는 방향은 반드시 내리막길을 걸어야하기 때문에, 먼저 비교할 필요가 있다.
  //먼저 방향을 설정하여 상하좌우에 따라 조건을 비교한다음, 조건이 성공하면 재귀함수로 다시 탐색한다. 재귀함수가 많지만 결국 0,0으로 가거나, 범위를 벗어나거나, 이미 탐색한 구조가 되기 때문에
  dp[row][col] = 0;
  //DP에 추가로 더해줄 조건만 잘생각하면 된다.
  for(int i=0;i<4;i++){
    //방향을 설정하기 때문에 for문으로 상하좌우를 비교하였다.
    int dx = go_x[i] + row;
    int dy = go_y[i] + col;
    if(map[row][col]<map[dx][dy]){ //항상 더 낮아야하고, 지금 경우는 목적지에서 출발지로 역산하기 때문에, 오히려 비교가 더 낮아야한다.
      dp[row][col] += DFS(dx,dy);
    }
  }
  return dp[row][col]; //모든 조건이 끝나 연산이 종료되면 자기 자신의 값을 반환하도록 한다.

}

int main()
{
  scanf("%d %d",&M,&N);
  // 선언 및 입력부
  for(int i=0;i<M;i++){
    for(int j=0;j<N;j++){
      scanf("%d",&map[i][j]);
    }
  }
  memset(dp,-1,sizeof(dp));
  printf("%d",DFS(M-1,N-1));
}
