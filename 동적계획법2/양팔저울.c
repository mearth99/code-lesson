//2629번 양팔저울
 /* 입력
첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다.
 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 
 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.
 */

 /* 출력
주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.
 */

/* 예상
추를 수평으로 맞춰서 무게를 비교하고 싶은 문제다. 구슬에 추를 추가하여 수평을 비교하던 지, 추만으로 구슬 무게를 맞춰 수평을 비교하는 두가지의 방법을 사용할 수 있다.
추가 여러개지만, DP를 통해 가능한 무게를 표로 정리한다면 계속 비교할 필요없이 이미 가능한 무게는 통과할 수 있다.
추로 나타낼 수 있는 무게는 N!의 경우의 수를 가지기 때문에, 양이 너무 많아진다. 이걸 DP를 통해 한번만 만들자.
다른버전 배낭문제네 이거! 근대 추의 무게를 포함한다..
dp[i][j] = i번째의 추까지 고려했을 때, j무게가 가능한지 측정한다.
다음 추를 선택한다. 다음 추를 선택하지 않는다. 다음 추를 구슬 무게에 더한다. 즉 현재 추 무게에서 뺀다.
*/
/* 결과
동적계획법은 곱씹을 수록 더 단맛이난다. 이번에는 abs 함수를 직접 구현해서 했는데 왠진 모르지만 오류가 있었다. 
아마 라이브러리와 충돌나면서 오류가 나타난게 아닐까. 
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int n,m,x;
int size[31];
int dp[31][40001]={0};

void cacu(int i, int j){
  if(i>n || dp[i][j]) return;
  dp[i][j] = 1;
  cacu(i+1,j+size[i]);
  cacu(i+1,abs(j-size[i]));
  cacu(i+1,j);
}
int main()
{
  scanf("%d",&n);
  for(int i=0;i<n;i++){
    scanf("%d",&size[i]);
  }
  cacu(0,0);
  scanf("%d",&m);
  for(int i=0;i<m;i++){
    scanf("%d",&x);
    if(x>40000) printf("N ");
    else if(dp[n][x]) printf("Y ");
    else printf("N ");
  }
}
