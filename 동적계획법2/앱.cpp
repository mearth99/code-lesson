//7579 앱

 /* 문제
    N개의 앱이 활성화되어 있다. 이들 앱은 각각 m만큼의 메모리를 사용하고 있으며, 비활성화 이후 다시 실행할 경우
    추가적 비용을 C로 수치화하였다. 따라서, 앱 N개 중 몇개를 비활성화 하여 M바이트 이상의 메모리를 확보하면서
    C의 합을 최소화 해야하는 것이다. 
 */
 /* 입력
 입력은 3줄로 이루어져 있다. 첫 줄에는 정수 N과 M이 공백문자로 구분되어 주어지며, 
 둘째 줄과 셋째 줄에는 각각 N개의 정수가 공백문자로 구분되어 주어진다. 
 둘째 줄의 N개의 정수는 현재 활성화 되어 있는 앱 A1, ..., AN이 사용 중인 메모리의 바이트 수인 m1, ..., mN을 의미하며, 
 셋째 줄의 정수는 각 앱을 비활성화 했을 경우의 비용 c1, ..., cN을 의미한다
 */

 /* 출력
필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하여 한 줄에 출력해야 한다. 
 */

/* 예상
사실, 목표가 C의 합을 최소화하는 것이기 때문에, C의 합을 최소화하는 DP를 구하면서 M바이트 메모리 이상이 될때 멈추면 된다.
다음걸 선택한다. 선택하지 않는다. 선택한 경우: 메모리와 함께 비용을 따로 계산한다. 원하는 메모리가 나타나면 최소값과 비교한다.
함수가 마무리 되면, 종료한다.
따라서, 시간을 선택한다. 선택하지 않는다라고도 볼 수 있다. 시간을 기준으로 냅색 DP를 설정한다면 시간은 j값이고 선택하거나 안한 갯수는 i가 된다.
DP[i][j] = max(DP[i-1][j] , DP[i][j-c[i]] + m[i])가 된다.
*/
/* 결과

*/
#include <iostream>
#include<algorithm>
using namespace std;

int N,M;
int dp[101][10001];
int c[101];
int m[101];


int main()
{
    //선언, 입력부
    int maxtime=0;
    cin >> N >> M;

    for(int i=0;i<N;i++){
        cin >> m[i];
    }
    for(int i=0;i<N;i++){
        cin >> c[i];
        maxtime+=c[i];
    }
    for(int i=0;i<N;i++){
        for(int j=0;j<=maxtime;j++){ //자. dp[i][j]는 i번째 선택에 j만큼 비용을 소모하여 찾은 메모리 값이다. 따라서 모든 시간을 비교하기 위해 maxtime을 최대값으로 정의헀다.
            if(dp[i][j]<M) //메모리보다 작은 경우 => 계속 DP를 반복하면서 찾아야한다.
                dp[i][j] = max(dp[i-1][j] , dp[i][j-c[i]] + m[i])
        }
    }
}
