//7579 앱

 /* 문제
    N개의 앱이 활성화되어 있다. 이들 앱은 각각 m만큼의 메모리를 사용하고 있으며, 비활성화 이후 다시 실행할 경우
    추가적 비용을 C로 수치화하였다. 따라서, 앱 N개 중 몇개를 비활성화 하여 M바이트 이상의 메모리를 확보하면서
    C의 합을 최소화 해야하는 것이다. 
 */
 /* 입력
    입력은 3줄로 이루어져 있다. 첫 줄에는 정수 N과 M이 공백문자로 구분되어 주어지며, 
    둘째 줄과 셋째 줄에는 각각 N개의 정수가 공백문자로 구분되어 주어진다. 
    둘째 줄의 N개의 정수는 현재 활성화 되어 있는 앱 A1, ..., AN이 사용 중인 메모리의 바이트 수인 m1, ..., mN을 의미하며, 
    셋째 줄의 정수는 각 앱을 비활성화 했을 경우의 비용 c1, ..., cN을 의미한다
 */

 /* 출력
필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하여 한 줄에 출력해야 한다. 
 */

/* 예상
사용자는 M메모리 이상을 확보해야하는데, 그 중 C의 값이 최소화되는 것을 찾고자 한다.
그렇다면, M메모리 이상 값을 모두 확인하여 C의 값이 최소화 되는 것을 사용해 볼 수 있다. 하지만 이 경우 확인할 가짓수가 너무 많아진다.
두번쨰로, C의 값을 낮은 순으로 정렬하여 M메모리 이상이 되는 걸 확인해 볼 수 있다.
그렇다면, dp[i][j] = M의 구조가 되고, i는 종료한 앱의 가짓수, j는 C의 값이다.
그러면, 우리는 앱을 선택하거나 선택하지 않는 냅색방법을 생각해볼 수 있다.
dp[i][j] = max(dp[i][j], dp[i-1][j-time[i]]+memory[i]); 라고 정의할 수 있는데 이는
현재 값과, 이전 시간에 대해서 비교할 수 있기 때문이다. 이렇게 비교하는 경우 모든 time에 대해 시간을 비교해봐야하고, 모든 j값을 탐색해봐야한다.
*/
/* 결과

*/
#include <iostream>
#include <algorithm>
using namespace std;

int N,M;
int DP[101][10001];
int times[101];
int memory[101];


int main()
{
    //선언, 입력부
    int maxtime=0;
    cin >> N >> M;

    for(int i=1;i<=N;i++){
        cin >> memory[i];
    }
    for(int i=1;i<=N;i++){
        cin >> times[i];
        maxtime += times[i]; //J값의 한계를 구한다.
    }
    for(int i=1;i<=N;i++){
        for(int j=0;j<=maxtime;j++){
            if(j>=times[i]){
                DP[i][j] = max(DP[i][j], DP[i-1][j-times[i]]+memory[i]);
            }
            DP[i][j] = max(DP[i][j],DP[i-1][j]);
        }
    }
    for(int j=0;j<=maxtime;j++){
        if(DP[N][j]>=M){
            cout << j;
            return 0;
        }
    }
}
