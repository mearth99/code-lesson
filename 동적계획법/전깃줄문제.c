/*
 전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때,
 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.
 첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100 이하의 자연수이다. 
 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 
 위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.

 전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 
 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.
*/
/*
 전깃줄이 교차한다는 걸 생각하면, 0과 1이 있을 때 i[0] > i[1] 이라는 값이면 전깃줄이 교차한다고 볼 수 있다. 전깃줄이 서로 교차하지 않기 위해서 삭제하는 개수를 구해야한다.
 처음 받는 전깃줄은 정렬이 안되어 있기 때문에 왼쪽 번호를 기준으로 정렬해야한다.
 정렬하고 나서는 LlS를 떠올리면 된다. 없애야하는 전깃줄의 최소 개수의 또 다른 말은 전체 - 가장 긴 전깃줄의 개수라고 볼 수 있다.
 이를 통해서 LlS를 구한 다음에, 전체에서 빼주면 된다. LlS 기준: 왼쪽으로 정렬된 오른쪽 전깃줄.
*/
#include <stdio.h>
int maxvalue(int a,int b)
{
    return a>b ? a : b;
}
void swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main()
{
    // 선언 및 입력부
    int ele[100][2];
    int D[100]={0};
    int input,max;

    scanf("%d",&input);
    for(int i=0;i<input;i++)
    {
        scanf("%d%d",&ele[i][0],&ele[i][1]);
    }
    // 왼쪽 기준 정렬부
    for(int i=0;i<input;i++)
    {
        for(int j=0;j<input-1;j++)
        {
            if(ele[j][0]>ele[j+1][0])
            {
                swap(&ele[j][0],&ele[j+1][0]);
                swap(&ele[j][1],&ele[j+1][1]);
            }
        }
    }
    //LIS 구현부 : 이전과 이후를 비교해서 값이 계속 커지지 않으면, 1을 주면 된다. 값이 계속 커지면 D[i-1] + 1 하면 된다.
    max = 1;
    for(int i=0;i<input;i++)
    {
        D[i] = 1;
        for(int j=0;j<input;j++)
        {
            if(ele[j][1]<ele[i][1])
            {
                D[i] = maxvalue(D[i],D[j]+1);
            }
        }
    }
    for(int i=0;i<input;i++)
    {
        if(max<D[i])
            max = D[i];
    }
    printf("%d",input-max);
    return 0;
}