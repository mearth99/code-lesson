/*
    인간 컴퓨터 상호작용
    '문자열에서 특정 알파벳이 몇 번 나타나는지 알아봐서 자주 나타나는 알파벳이 중지나 검지 위치에 오는 알파벳인지 확인하면 실용적인지 확인할 수 있을 것이다.'
    특정 문자열 S, 특정 알파벳 a와 문자열의 구간 [l,r]이 주어지면 S의 l번째 문자부터 r번째 문자 사이에 a가 몇 번 나타나는지 구하는 프로그램을 작성하여라. 
    승재는 문자열의 문자는 0번째부터 세며, l번째와 r번째 문자를 포함해서 생각한다.
    첫 줄에 문자열 S가 주어진다. 문자열의 길이는 200,000자 이하이며 알파벳 소문자로만 구성되었다. 두 번째 줄에는 질문의 수 q가 주어지며, 
    문제의 수는 1<= q<= 200,000을 만족한다. 세 번째 줄부터 (q+2)번째 줄에는 질문이 주어진다. 각 질문은 알파벳 소문자 a_i와 0<=l_i<= r_i<|S|를 만족하는 정수 
    l_i,r_$가 공백으로 구분되어 주어진다.
*/
/*
    알파벳 소문자로 이루어져 있다. a: 97 z: 122 26개
    문자열 a_i가 정해진다면, 현재까지 a_i가 몇번 나왔는지 늘려나가면 된다. 그리고 범위 l과 r을 포함하기 때문에 sum[r] - sum[l-1]을 하면 구할 수 있다.
*/
#include <stdio.h>
#include <string.h>


int main()
{
    //선언
    int sum[26][200001]={0}; //[알파벳][문자열]
    char data[200001];
    int length,N,l,r;
    char alpa;
    //입력
    scanf("%s",data);
    //계산
    length = strlen(data);

    for(int i=0;i<length;i++)
    {
        sum[data[i]-'a'][i]++;
    }
    for(int i=0; i<26;i++)
    {
        for(int j=1;j<length;j++)
            sum[i][j] += sum[i][j-1];
    }
    scanf("%d",&N);
    for(int i=0;i<N;i++)
    {
        scanf(" %c%d%d",&alpa,&l,&r);
        if(l==0)
            printf("%d\n",sum[alpa-'a'][r]);
        else
            printf("%d\n",sum[alpa-'a'][r]- sum[alpa-'a'][l-1]);
    }
    return 0;
}
/*
    이번 문제는 15번 틀렸다. 다 내불찰이다. sum을 char 배열로 잡아서 값을 많이 넣을 수 없으니 큰 계산을 할때 망가지게 되었다.
    이게 어떤 문제였냐면, 백준에서 절반까지는 계산이 가능하다가, char 형 범위를 벗어나는 순간 계산 값이 오버플로우되어서 난리났다.
    그래서 디버깅이 더 오래걸렸다.

    그리고 vscode에서 heap 메모리 문제로 인해 c를 돌릴때 변수 배열을 크게 잡을 수 없다는 걸 알았다. 
    다만 전역변수를 사용한다면 heap에 해당하지 않기 때문에 / 전역변수는 stack에 해당한다. 그래서 전역변수 배열로 사용한다면
    vscode에서도 gcc가 무사히 실행된다.
*/